# dunai-oauth-provider
# Авторизация на базе OAuth 2.0

## Преимущества
- защита от кражи обоих токенов
    - до истечения срока жизни refresh_token
    - до входа настоящего пользователя

## Недостатки
- во всех описанных здесь схемах украденный хакером access_token
    будет действовать до истечения его срока жизни
- отсутствует механиз отзыва access_token
    - можно нивелировать уменьшением срока жизни access_token'а
    - в случае критичности проверок сессии стоит рассмотреть
    иные варианты поддержании сессии

## Схемы взаимодействия
### Создание и использование токенов

1. Пользователь логинится, передавая логин + пароль
2. В случае упеха сервер выдает ему пару access_token + refresh_token
    - refresh_token
        - имеет большее время жизни (30 дней)
        - время его смерти
        - user_id
        - devid которое генерируется случайно и только при логине пользователя
        - uuid - уникальный идентификатор токена
    - access_token имеет короткое время жизни (1 час)
        - user_id
        - uuid refresh_token для обязательной проверки
            в более критичных местах
3. Клиент сохраняет оба токена
4. При каждом запросе клиент проверяет время жизни access_token
    и если время жизни токена истекло, используя refresh_token,
    обновляет ОБА токена
5. Клиент с каждым запросом передает access_token

### Обновление токенов на сервере

1. Клиент проверяет, нужно ли обновить токен.
    Это могут быть разные стратегии:
    - проверять перед каждым запросом
    - проверять периодически
    - проверять что срок жизни токена скоро истечет и заранее его обновить
2. Если клиент решил обновить токен, он выполняет запрос на обновление
    прикладывая refresh_token
3. Проверяет валидность и срок действия refresh_token'а
4. Ищет в баже refresh_token с таким же devid
    (не может быть два токена с одним devid)
5. Проверяет что найденый и переданый токены совпадают
6. В случае несовпадения, невалидности или истечения срока жизни токена:
    - удаляет токен из базы с тем же devid
    - сервер отказывает в обновлении токена
7. В случае успеха сервер:
    - создает и перезаписывает refresh_token'ы в БД
        сохраняя devid и обновляя срок жизни
    - создает новый access token
8. Клиент получает новую пару токенов

### Выход (logout) пользователя

1. Клиент отправляет запрос на logout, прикладывая refresh_token
2. Сервер удаляет из базы информацию об этом refresh_token
8. Клиент удаляет локально сохраненные токены

### В случае кражи (обоих токенов):
Что произойдет в случае кражи обоих токенов
1. Хакер воспользовался access_token'ом
0. Закончилось время жизни access_token'на
0. Клиент хакера отправляет refresh_token
0. Хакер получает новую пару токенов
0. На сервере создается новая пара токенов("от хакера")
0. Пользователь пробует зайти на сервер
0. Сервер находит refresh_token с тем же devid но переданный и
    сохраненный в базе токены отличается
0. Сервер удаляет сохраненный в базе токен
0. Сервер отказывает в доступе пользователю
0. Клиент перенаправляет пользователя на форму логина где ему сервер
    после успешного логина выдаст новую пару токенов с новым devid

## Дополнения
    1. Хранить список валидных данных принадлежащим владельцу токена:
        - deviceID
        - fingerprint браузера
        - IP/Subnet (в этом случае при каждой попытке зайти с новой
         точки доступа к интерету придется перелогиниватся)
    2. Проверять количество активных refresh_token'он,
        большое количество refresh_token'ов выглядит подозрительно
